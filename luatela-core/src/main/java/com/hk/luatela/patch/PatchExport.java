package com.hk.luatela.patch;

import com.hk.luatela.patch.models.Model;
import com.hk.luatela.patch.models.fields.DataField;
import com.hk.str.HTMLText;
import com.hk.str.StringUtil;

import java.util.*;

public class PatchExport
{
	private final LuaBase base;
	private final PatchComparison comparison;

	public PatchExport(LuaBase base, PatchComparison comparison)
	{
		this.base = base;
		this.comparison = comparison;
	}

	public String getName()
	{
		if(base.patchModelSet.getPatchCount() == 0)
			return "patch-1-initial";
		else
			return "patch-" + (base.patchModelSet.getPatchCount() + 1);
	}

	public HTMLText toLua(HTMLText txt)
	{
		long time = System.nanoTime();
		int patchNo = base.patchModelSet.getPatchCount() + 1;

		txt.prln("--[[").tabUp();
		txt.wrln(StringUtil.repeat("-", 50));
		txt.prln("Generated by Lua Tela on");
		txt.prln(LuaBase.FULL_FORMAT.format(new Date()));
		txt.wrln(StringUtil.repeat("-", 50));
		txt.pr("Patch #").wrln(String.valueOf(patchNo));
		txt.pr("Elapsed Time: ").makeVar("elapsed").wrln("ms");
		txt.wrln(StringUtil.repeat("-", 50));
		txt.tabDown().prln("]]").ln();

		txt.pr("if patchNo ~= ").wr(String.valueOf(patchNo)).wrln(" then").tabUp();
		txt.prln("return false");
		txt.tabDown().prln("end");
		txt.prln("patchNo = patchNo + 1").ln();

		if(comparison.newModels != null && comparison.newModels.length > 0)
		{
//			txt.prln("do").tabUp();
			for (Model newModel : comparison.newModels)
			{
				txt.pr("models['").wr(newModel.name).wrln("'] = {").tabUp();
				toLua(txt, newModel);
				txt.tabDown().prln("}");
			}
//			txt.tabDown().prln("end");
			txt.ln();
		}

		txt.wr("return true");

		txt.setVar("elapsed", String.valueOf((System.nanoTime() - time) / 1000000D));
		return txt;
	}

	private void toLua(HTMLText txt, Model model)
	{
		List<DataField> fields = model.getFields();

		for (DataField field : fields)
		{
			txt.pr("['").wr(field.name).wr("'] = { ");
			toLua(txt, field);
			txt.wrln("},");
		}
	}

	private void toLua(HTMLText txt, DataField field)
	{
		txt.wr("'").wr(field.name().substring(7).toLowerCase()).wr("', {");
		Map<String, String> props = field.exportProps(new LinkedHashMap<>());

		Iterator<Map.Entry<String, String>> itr = props.entrySet().iterator();

		while(itr.hasNext())
		{
			Map.Entry<String, String> entry = itr.next();

			txt.wr(entry.getKey()).wr("=").wr(entry.getValue());

			if(itr.hasNext())
				txt.wr(", ");
		}

		txt.wr("} ");
	}
}
